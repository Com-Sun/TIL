# Call by value

메소드에 값(primitive type)을 전달하는 것과 객체(reference type)를 전달하는 것에는 큰 차이가 있다.

결론부터 이야기하자면, 메소드로 객체를 전달할 경우 메소드에서 객체의 객체변수(속성)값을 변경할 수 있다.

C로 바꾸어 생각해보면 함수의 인자에 **포인터**를 전달할 경우 포인터가 가리키는 **변수**를 변경할 수 있다.

예시를 보자.

    package jumpToJava;

    public class Counter {
        int count = 0;

        public static void main(String[] args) {
            Counter myCounter = new Counter();
            System.out.println(myCounter.count);
            
            Updater myUpdater = new Updater();
            myUpdater.update(myCounter.count);
            System.out.println(myCounter.count);

        }//end main

    }//end class

    class Updater {
        public void update(int count) {
            count++;
        }
    }//end class

결과

    0
    0

지금까지와 다른점이 있다. 클래스가 2개이다. 이 경우 파일이름과 같은 클래스는 public을 붙여주는것이 관례이다.

우선 Counter클래스를 보자. int 자료형 count라는 객체변수가 있다.

main 메소드엔 Counter 타입 myCounter, Updater타입 myUpdater라는 객체가 있다.

우선 myCounter객체의 객체변수 count 를 출력해보면 0 이 나온다. 다음에 myUpdater이라는 객체에 인자로 (myCounter.count)라는 수를 전달했다. myUpdater는 인자를 1 더해주는 객체이다. 그런데 출력된 결과물을 보니 1이 아닌 0이 나왔다. 왜 그럴까?

이전에 배웠든, 각각의 메소드(함수)에 들어있는 변수는 서로에게 아무런 영향을 주지 못한다. 즉, myUpdater.update(input)을 해봤자 Updater 메소드에서만 1이 증가하지, main 메소드에는 아무런 영향이 없다. 

C에선 이를 해결하기 위해 포인터를 사용했다. 예를들어 int a의 값을 변경하고 싶으면 인자에 a의 포인터, pa를 전달하면 a의 값을 변경할 수 있었다.

위와 유사하게, 자바에선 인자에 **객체**를 전달한다.

예시를 보자.

    package jumpToJava;

    public class Counter {
        int count = 0;

        public static void main(String[] args) {
            Counter myCounter = new Counter();
            System.out.println(myCounter.count);
            
            Updater myUpdater = new Updater();
            myUpdater.update(myCounter);
            System.out.println(myCounter.count);


        }//end main

    }//end class

    class Updater {
        public void update(Counter input) {
            input.count++;
        }
    }//end class

달라진 부분이 두 곳이 있다.

1.

    main함수 안의 myUpdater.update(myCounter.count); => myUpdater.update(myCounter);

myCounter.count는 객체가 아니다. 코드에 의하면 0이라는 정해진 값이다. 그러니 이를 mtCounter이라는 객체로 바꾸어 전달해야 한다.

2.

    class Updater {
    public void update(Counter input) {
        input.count++;
    }

선언부 : 원래의 코드에서 인자에 전달되는 값은 int 형 이었다. 하지만 그 값은 Counter형으로 바뀌었다. 

구현부 : 원래의 코드에서 인자를 ++ 해주고 끝이었다. 하지만 이번엔 인자.count++(인자의 객체변수)를 직접 +1 해준다.  

# 상속

## IS-A 관계

## 메소드 오버라이딩(method overriding)

## 메소드 오버로딩(method overloading)

## 다중 상속