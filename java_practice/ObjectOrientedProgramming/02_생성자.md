# 객체 초기화

지금까지  만든 프로그램을 살펴보자.

Program 클래스와 ExamList 클래스가 있었다.

    class Program {
        public static void main() {
                    = new ExamList();
        }
    }//end Program

    class ExamList {
        private Exam[] exams
        private int current;

        public void init() {
            exams = new Exam[3];
            current = 0;
        }
    }//end ExamList

객체가 초기화되는 과정을 제대로 이해하자.

    new ExamList();

new 연산자를 사용하여 ExamList를 호출하는 과정을 **실체화**라고 한다. 이 과정을 하나하나 보면

1. new라는 연산자를 통해 ExamList라는 데이터 구조가 메모리에 실재하게된다. 이 때 메모리엔 exams, current 두 개의 데이터가 존재하는 상황이다.

2. ExamList라는 데이터 구조를 사용하기 위해선 이름이 필요하다. 그래서

        class Program {
            public static void main() {
                ExamList list  = new ExamList();
            }
        }//end Program

3. 식별하기 위해 이름을 부여한다. 즉, list는 ExamList 자료형을 식별하기 위한 이름이다. 그런데 아직 exams와 current는 NULL 값을 가리킨다. 이번엔 list를 초기화시킬 차례이다.
   
        public void init()

4. 위의 함수를 메인함수에서 사용하면 값을 초기화한다.

        class Program {
            public static void main() {
                ExamList list = new ExamList();
                list.init();
            }
        }//end Program

5. 이제 list의 exams는 3개의 배열을 갖고, current는 0을 갖는다.

        list.inputList()

6. 이전 문서에서 만들어놓았던 위의 메소드를 사용하면 각각의 배열엔 kor, eng, math라는 값이 들어가게 된다.

지금까지 객체의 초기화과정에 대해 복습했다. 위의 방법은 그다지 바람직한 방법이라 할 수 없다. 왜냐, init이라는 초기화 함수는 단 한번만 사용되어야하기 때문이다. 그래서 **생성자**라는 개념이 등장했다.

# 생성자(Constructor)

생성자 : 초기화를 위한 특별한 함수.

1. 객체가 생성 되자 마자 무조건 제일 먼저 실행되어야만 한다.
2. 생성될 때 단 한번만 실행되어야만 한다.

코드를 확인해보자.

    public void init() {
            exams = new Exam[3];
            current = 0;
        }

이전까지 객체를 초기화하기 위해 init이라는 함수를 만들었다. 이것을 생성자로 바꾸면

	public ExamList() {
		exams = new Exam[3];
		current = 0;
	}

이렇게 개선할 수 있다. 

# 생성자 오버로드

	public ExamList() {
		exams = new Exam[3];
		current = 0;
	}

이 코드를 오버로드 하는 예시를 보자.

	public ExamList(int size) {
		exams = new Exam[size];
		current = 0;
	}

이렇게 할 경우 객체를 초기화할때 사이즈만큼의 배열을 만들 수 있다.
