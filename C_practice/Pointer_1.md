# 포인터

    포인터는 메모리상에 위치한 특정한 변수의 주소값을 보관하는 '변수'이다.

&단항 연산자 : 변수의 주소값을 찾는 연산자

\*단항 연산자 : 위와 반대로, 변수의 주소값에서 데이터를 가르키는 연산자.

    int main()
    {
        int a = 2;
        int *p;
        p = &a;

        printf("%d", *p);
        return 0;
    }

내가 코딩하며 틀린 부분 : p = &a가 아닌, *p = &a 라고함.
*p는 주소값이 아닌 주소값이 가르키는 데이터이다. 즉, a와 동의어이다. a에 a의 주소값을 넣어서 컴파일 오류가 났던 것이다.

## 포인터의 타입

포인터는 int형, char형과 같이 '형'이 존재한다.
이유를 생각해 보자. 포인터는 메모리 어딘가에 저장된 변수를 가르킨다. 이 때 컴퓨터는 변수가 '시작'하는 부분만 알 수 있다. 데이터 형이 없을 경우, 컴퓨터의 입장에서 얼마만큼의 데이터를 읽어들여야 할 지 알 수 없다.

# 상수 포인터 const *int, int *const 다른점

상수란 변수와는 달리 절대로 변하면 안되는 (변)수이다.

    int main()
    {
        const int a = 2;
        a = 3;
        printf("%d", a);

        return 0;
    }

위와 같이 상수 a에 3을 대입하면 컴파일 오류가 나게 된다.
상수는 개발자의 실수를 줄이는데 도움을 준다.

이제 const *int 와 int *const의 차이를 알아보자.

    int main()
    {
        int a;
        int b;

        const int* p = &a;

        *p = 3; // 틀린 문장
        p = &b; //맞는 문장


        return 0;
    }

위의 코드에서 상수는 int이다. 포인터 p에는 a의 주소값이 들어가있다. 여기서 포인터의 주소값 p는 변수이지만, \*p가 가르키는 데이터 형 int는 상수이므로 바꿀 수 없다.

    int main()
    {
        int a;
        int b;

        int* const p = &a;

        *p = 3; //맞는 문장
        p = &b; //틀린 문장


        return 0;
    }

반대로, 이 코드를 살펴보자. 이번엔 상수가 int가 아닌 포인터이다.
*p가 가르키는 데이터 형 int는 변수이기에 *p = 3이 맞는 문장이다.
반면에, p는 상수이기에 주소값에 b의 주소값을 대입하는 p = &b는 틀린 말이 된다.

### 내가 코딩하며 헷갈렸던 부분

    int* const p = &a

위 코드를 초기화하는데 있어서 처음에 다음과 같이 실수했다.

    int const *p = &a

왜나면 포인터 변수를 선언할 때 int* p, int *p둘 중에서 나는 주로 후자를 선택했는데, \*연산자가 이름 p앞에 붙어야한다고 생각했기 때문이다.

    int *const p = &a

이름 앞에 \*연산자를 사용하려면 위와 같이 사용해야 한다.

# 포인터의 덧셈과 뺄셈

- 포인터에 정수를 더하거나 뺄 수 있다.
- 하지만 포인터끼리의 덧셈을 불가능하다. (뺄셈은 가능하다.)

예시를 보며 이해해 보자. 우선, 내가 실수한 부분은 다음과 같다.

    int main()
    {
        int* a =1;
        char* b =2;
        double* c =3;

        printf("%p\n", a);
        printf("%p\n", a + 1);
        printf("%p\n", b);
        printf("%p\n", b + 1);
        printf("%p\n", c);
        printf("%p\n", c + 1);



        return 0;
    }

![0](/img/pointer_0.PNG)

결과물이 뭔가 이상하다. 우선, 교수자의 예시를 보자.

![1](/img/pointer_1.PNG)

어딘가 많이 잘못됐음을 알 수 있다. 내가 어떤 실수를 했는지 코드를 다시 한 번 살펴보았다.

    int* a =1;

이를 해석하자면, **포인터 a의 주소값에 1을 대입하라** 인데, 포인터 a의 주소값에 메모리의 00000001라는 주소값을 그대로 대입한 것이었다.
그렇다면 지금, 메모리의 주소 00000001, 00000002, 00000003에는 각각 자료형의 크기가 다른 변수 a,b,c가 들어가 있는 상황일 것이다.
이를 확인해보기 위해 %d를 사용하여 컴파일 해보았다.

    int main()
    {
        int* a =1;
        char* b =2;
        double* c =3;

        printf("%d\n", *a);
        printf("%d\n", *b);
        printf("%d\n", *c);

        return 0;
    }

![2](/img/pointer_2.PNG)

예상한 바와 같이, 메모리의 주소가 겹쳐버려 오류가 발생했다.
오류를 수정하기 전에 a,b,c의 주소를 자료형의 크기만큼 차이를 두고 컴파일 해 보았는데 컴파일 되지 않았다. 메모리의 주소를 직접 입력하는 것은 근본적으로 막혀있는듯 보였다.

다행히 틀린 부분을 알았으니, 오류를 고쳐보았다.

        int a;
        char b;
        double c;

        int* pa = &a;
        char* pb = &b;
        double* pc = &c;


        printf("%p\n", pa);
        printf("%p\n", pa + 1);
        printf("%p\n", pb);
        printf("%p\n", pb + 1);
        printf("%p\n", pc);
        printf("%p\n", pc + 1);

        return 0;

![3](/img/pointer_3.PNG)

성공적으로 컴파일 되었다. 뺄셈도 덧셈과 동일하게 생각하면 될 것이다.

## 포인터끼리의 덧셈

위에선 포인터에서 정수를 더했다. 그렇다면, 포인터끼리 더하는 것을 어떨까?
결과만 말하자면, 포인터끼리의 덧셈은 불가능하다. 애초에 의미가 없는 행위이기 때문이다.

반면에, 포인터끼리의 뺄셈은 가능하다고 한다.

# 배열과 포인터와의 관계

배열의 각 원소는 메모리에서 연속적으로 존재한다.
이 특성으로 인해 포인터로 배열의 각 원소에 쉽게 접근할 수 있다.

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        int* parr;

        parr = &arr;

        for (int i = 0; i < 5; i++)
        {
            printf("arr:%p, pointer:%p\n", &arr[i], parr + i);
        }

        return 0;
    }

![4](/img/pointer_4.PNG)

위의 코드에서 나는 크기가 5인 배열 arr를 만들었다.
또한, parr이라는 포인터를 만든 뒤 arr의 주소값을 할당했다.
컴파일 결과를 확인해보면, 배열 arr의 주소와 포인터 parr의 주소가 일치함을 알 수 있다. 즉, parr + 1이 int형의 크기만큼 곱해져서 4씩 증가하였다. 메모리에서 연속적으로 존재하는 배열의 특성상, 포인터의 덧셈을 활용하면 각 원소에 쉽게 접근할 수 있게 된다.

### 참고 : 포인터의 덧셈은 각 자료형의 크기만큼 곱해져서 행해진다.

# 배열과 포인터의 특성

배열의 이름은 배열의 첫 번째 원소의 주소값을 나타낸다.

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        int* parr;

        parr = &arr;


        printf("%p, %p\n", arr, &arr[0]);


        return 0;
    }

![5](/img/pointer_5.PNG)

**하지만**, 배열의 이름 arr이 배열의 첫 번째 원소를 가르키는 포인터는 아니다.
이는 sizeof 연산자를 활용해서 확인 가능하다.

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        int* parr;

        parr = &arr;


        printf("%p, %p\n", arr, parr);
        printf("%d, %d", sizeof(arr), sizeof(parr));

        return 0;
    }

![6](/img/pointer_6.PNG)

확인해보니 배열 arr의 크기는 전체 크기인 20, parr의 크기는 포인터의 크기 4가 나온다. (32비트의 경우 4, 64비트일 경우 8)
주소값은 같은데, 크기는 다른 것이 가능한 일일까?

그 이유에 대해, C언어에선 sizeof나 &연산자를 사용할 때를 제외하고는, **배열의 이름을 사용 시 암묵적으로 배열의 첫 번째 원소를 가르키는 포인터로 타입 변환** 된다고 한다.

## 복습하며 헷갈렸던 부분

        int* parr = arr;
        int* parr = &arr;

위의 코드는 printf를 사용해보면 같은 결과가 나온다. 나는 왜 이게 같은 값이 나오는지 궁금했다.

앞에서 강조했던 '배열의 이름을 사용시, 배열의 첫 번째 원소를 가르키는 포인터로 타입 변환'에 의하면 &arr은 그러면 포인터의 주소값, 즉 이중 포인터가 되는 것이 아닌가?

하지만 다시 복습하는 과정에서 나는 'sizeof 와 &연산자'는 제외라는 부분을 발견했고, 그제서야 이해했다. &연산자는 이중포인터가 되는것을 방지하기 위해 막아둔 것이 아닐까? 마지막으로 제대로 이해하기 위해 코드를 다시 써 보았다.

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        int* parr = arr;

        printf("%p, %p, %p, %p\n", arr, &arr ,&arr[0], parr);
        printf("%d, %d, %d, %d", sizeof(arr), sizeof(&arr), sizeof(&arr[0]), sizeof(parr)) ;

        return 0;
    }

![8](/img/pointer_8.PNG)

~~arr, &arr, &arr[0], parr 모두 가르키는 주소값은 동일하다.
하지만 크기는 다르다. 배열의 이름 arr은 배열 전체의 크기를 가진다. 나머지 &arr, &arr[0], parr은 모두 int형 원소 하나의 크기를 가진다.~~

아직 &arr에 대한 이해가 없었을 때 작성한 문서로, 이 부분에 대해선 Pointer_2 에서 다시 작성되었다.

# [] 연산자

수학에서 []는 대괄호이다. 신기하게도, C언어에선 연산자로 쓰인다.
예시를 통해 확인해보자.

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        printf("%d, %d", arr[3], *(arr + 3));

        return 0;
    }

![7](/img/pointer_7.PNG)

와우! 위의 코드를 통해 신기한 사실을 확인할 수 있다. 컴퓨터에서 arr[3]은 사실 \*(arr + 3)으로 바꿔서 처리한다는 것이다. arr이 sizeof나 &연산자와 사용되지 않았기에, 암묵적으로 첫번째 원소를 가르키는 포인터로 사용되었다.

이를 활용하면 더 신기한 연산도 할 수 있다.

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        printf("%d, %d", 3[arr], *(arr + 3));

        return 0;
    }

즉, 3[arr]이나, arr[3] 이나 똑같이 \*(arr +3)으로 처리된다.
