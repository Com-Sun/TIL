# 1 차원 배열을 가리키는 포인터

1차원 배열을 가리키는 포인터 하나를 만들어보자.

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        int* parr;
        parr = arr;

        while (parr - arr < 5)
        {
            printf("%d\n", *parr);
            parr++;
        }

        return 0;
    }

![10](/img/pointer_10.PNG)

여기서 궁금한 점 하나. 왜 그냥 arr++을 사용하지 않고, parr을 만들어서 간접적으로 arr을 참조할까?

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        int* parr;
        parr = arr;

        while (arr < 5)
        {
            printf("%d\n", *arr);
            arr++;
        }

        return 0;
    }

이렇게 하면 컴파일조차 되지 않는다.
그 이유에 대해 알아보자.

        printf("%p", arr);

배열의 이름을 사용하면 암묵적으로 배열의 처음을 가리키는 포인터로 타입 변환된다고 배웠다. 즉, 이 부분을 컴파일하면 다음과같은 결과를 얻는다.

    00FFFBC0

즉, 위의 문장은 컴파일러 입장에서 (00FFFBC0)++을 수행한 것이다. 당연히 오류가 뜰 것이다.
하지만 포인터의 덧셈의 경우, 자료형의 크기만큼 곱해져서 더해진다고 배웠다. 그렇기에 배열의 포인터 parr을 통해 간접적으로 arr의 덧셈을 수행하는 것이다.

여기서 생긴 궁금증. 그렇다면 arr++가 아닌, arr = arr +4를 하면 컴파일이 되지 않을까?

    while (arr < 5)
    {
        printf("%d", *arr);
        arr = arr + 4;
    }

위와같이 코드를 작성했는데, 컴파일은 불가능했다. 궁금해서 찾아보니, 그 이유는 다음과 같았다.

    배열의 주소값은 상수이다.

즉, 메모리에 저장된 배열의 주소값은 임의로 할당할 수 없는 것이었다!
이를 알고나니 이전 문서에서 주소값에 직접 00000001을 대입한 것이 생각났다. 그때도 컴파일 오류가 났었는데 메모리속 주소를 직접 변경하는것은 불가능한 것 같다.

## 포인터의 포인터

    int main()
    {
        int a;
        int* pa;
        int** ppa;
        a = 2;

        pa = &a;
        ppa = &pa;

        printf("%d, %d, %d\n", a, *pa, **ppa);
        printf("%p, %p, %p\n", &a, pa, *ppa);
        printf("%p, %p\n", &pa, ppa);

        return 0;
    }

![9](/img/pointer_9.PNG)

위 코드를 살펴보자. printf문에서 같은 행에 있는 모든 변수는 같은 값을 가진다.
a의 주소값을 가리키는 포인터 pa. 이는 &a와 같으며, pa의 주소값을 저장한 ppa가 가리키는 데이터 \*ppa와 같다.

즉, &a = pa = \*ppa이다.

마지막줄도 이와 같이 해석할 수 있다.
pa의 주소값 &pa와, 이를 저장하고있는 ppa는 같은 값이다.

## 배열 이름의 주소값

배열의 이름 arr은 특정 상황을 제외하고 암묵적으로 배열의 첫 번째 원소를 가리키는 포인터로 타입 변환된다.

    parr = arr

즉, 위 코드에서 arr 이 &arr[0]로 변환되는 것이다. 그렇다면 다음의 코드는 무엇을 의미할까?

    parr = &arr

arr이 포인터로 변환되니 포인터의 주소값, 즉 이중포인터가 되는 것일까? 정답은 아니다. arr의 타입 변환은 '&'연산자가 쓰이면 이뤄지지 않는다.

### 애초에 parr = &arr이라는 코드는 틀렸다.

배열 이름의 주소값을 사용하려면 코드는 다음과 같아야 한다.

    int arr[5] = { 0, 1, 2, 3, 4 };
    int (*parr)[5] = &arr;

    printf("%p, %p, %d, %d, %d", parr, &arr, sizeof(parr), sizeof(&arr), sizeof(arr));

arr의 크기만큼의 int\*타입 포인터를 초기화했다.
예상한 대로, 실행 결과는 다음과 같다.

![11](/img/pointer_11.PNG)

여기서 알아야 할 것은 parr과 arr의 차이이다. 두 값 모두 같은 값을 가지지만, 타입이 다르다. arr의 타입은 int, parr의 타입은 int\*이다.
이렇게 (요상하게)동작하는 이유는 사실 C언어가 B언어에서 파생된 역사 때문이다.

### C언어의 짧은 역사

C언어와는 달리, B언어에선 배열이 있고, 배열을 가리키는 포인터가 따로 존재했다. 즉, arr과 arr[0], arr[1]은 각기 각기 다른 메모리를 차지했다.

여기서 arr은 arr[0]를 가리키는 포인터였다. 즉, arr을 출력하면 실제로 &arr[0]의 주소값이 나왔다. 또한, &arr은 arr의 주소값이 나왔다. 따라서, B언어에선 arr과 &arr이 서로 다른 값을 출력했을 것이다.

## 마지막으로 헷갈리는 부분

    1.  int arr[5] = { 0, 1, 2, 3, 4 };
        int (*parr)[5] = arr;

        printf("%p, %p, %d, %d, %d", parr, &arr, sizeof(parr), sizeof(&arr), sizeof(arr)); //공통으로 적용

    2.  int arr[5] = { 0, 1, 2, 3, 4 };
        int (*parr)[5] = &arr;

    3.  int arr[5] = { 0, 1, 2, 3, 4 };
        int *parr = &arr;

    4.  int arr[5] = { 0, 1, 2, 3, 4 };
        int *parr = arr;

4개의 코드를 거치며 (*parr)[5]를 선언할 때와, 그냥 *parr을 선언할 때 결과는 다르지 않았다. 또한, 그냥 arr을 대입했을 때와 arr의 주소값 &arr을 대입했을 때에도 그러했다. 위 코드의 차이가 무엇일까? 차후에 알게 되면 이 문단을 수정하겠다.

# 2 차원 배열을 가리키는 포인터 (배열 포인터)

지금까지 1차원 배열을 가리키는 포인터에 대해 학습했다. 이제는 차수를 높혀 2차원 배열을 가리키는 포인터에 대해 알아볼 차례이다.

    int main()
    {
        int arr[2][3] = { {1,2,3}, {4,5,6} };

        printf("%p, %p\n", arr[0], &arr[0][0]);
        printf("%p, %p\n", arr[1], &arr[1][0]);

        return 0;
    }

![12](/img/pointer_12.PNG)

**arr[0]은 &arr[0][0]과 같고, arr[1] 또한 &arr[1][0]과 같다.** 우리는 이와 비슷한 것을 이전에 학습한 적 있다. 1차원 배열에서 arr 자체만 사용하면, 암묵적으로 타입 변환되는 것이다.

2차원 배열도 마찬가지로, arr[0]는 암묵적으로 arr[0][0]을 가리키는 포인터로 변환됨을 알 수 있다.

## 행과 열 계산하기

    int arr[2][3] = { {1,2,3}, {4,5,6} };

    printf("전체크기 :%d, 열의 크기:%d, 데이터 하나의 크기:%d, 행의 갯수 :%d", sizeof(arr), sizeof(arr[0]), sizeof(arr[0][0]), sizeof(arr)/sizeof(arr[0]));

![13](/img/pointer_13.PNG)

2행 3열의 배열이다. sizeof(arr[0])은 sizeof에 일차원 배열을 전달한 것과 같다. sizeof(arr[0][0])은 int의 크기 4를 반환한다.

여기서 알 수 있는 사실 : **arr[0][0]은 int형이므로 arr[0]은 int\*형이 된다.** (이 부분이 헷갈려서 printf로 직접 출력해보자)

    int arr[2][3] = { {1,2,3}, {4,5,6} };
    printf("%d %d", arr[0][0], arr[0]);

![14](/img/pointer_14.PNG)
오류 메시지를 확인해보니, 인수2의 형식이 int\*라고 한다. 우리는 위에서 arr[0]이 &arr[0][0]으로 암묵적으로 변환된다고 배웠으니 이해가 쉬울 것이다.

자, 여기서 더 그럼 한 단계 더 나가아보자. int형 이차원배열에서 arr[0]의 자료형은 int\*이다. 그렇다면 그냥 arr의 자료형은 int\*\*일까?

답은 **아니다.**

# 포인터의 형(type) 결정하기

이차원 배열을 가리키는 포인터는 다음과 같아야 한다.

    int arr[2][3] = { {1,2,3}, {4,5,6} };
    int(*parr)[3];
    parr = arr;

    printf("%d", parr[1][1]);

이차원 배열을 가리키는 포인터에는 반드시 행의 길이에 대한 정보가 포함돼야 한다.

    int(*parr)[3];

위 코드를 보면 어딘가 익숙하다.
크키가 3인 배열을 가리키는 포인터와 정확히 같은 모양이다.
자, 다시 마지막으로 정리를 해보자.

1차원 배열에서 arr : 암묵적으로 배열의 첫 번째 원소를 가리키는 포인터로 타입변환. (&arr[0])

2차원 배열에서 arr : 암묵적으로 배열의 첫 번째 행을 가리키는 포인터로 타입변환. (&arr[0])

2차원 배열에서 arr[0] : 암묵적으로 배열의 첫 번째 행,열을 가리키는 포인터로 타입변환. (&arr[0][0])

2차원 배열을 가리키는 포인터 선언 : 반드시 행의 길이에 대한 정보를 포함해야한다. int(\*parr)[3]

# 포인터 배열

포인터 배열이란, 각각의 원소가 포인터인 **배열**이다.

    int *arr[3];
    int a = 1;
    int b = 2;
    int c = 3;

    arr[0] = &a;
    arr[1] = &b;
    arr[2] = &c;

    printf("%d, %d, %d", *arr[0], *arr[1], *arr[2]);

    return 0;
