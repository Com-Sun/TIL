# 1 차원 배열을 가르키는 포인터

1차원 배열을 가르키는 포인터 하나를 만들어보자.

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        int* parr;
        parr = arr;

        while (parr - arr < 5)
        {
            printf("%d\n", *parr);
            parr++;
        }

        return 0;
    }

![10](/img/pointer_10.PNG)

여기서 궁금한 점 하나. 왜 그냥 arr++을 사용하지 않고, parr을 만들어서 간접적으로 arr을 참조할까?

    int main()
    {
        int arr[5] = { 0, 1, 2, 3, 4 };
        int* parr;
        parr = arr;

        while (arr < 5)
        {
            printf("%d\n", *arr);
            arr++;
        }

        return 0;
    }

이렇게 하면 컴파일조차 되지 않는다.
그 이유에 대해 알아보자.

        printf("%p", arr);

배열의 이름을 사용하면 암묵적으로 배열의 처음을 가르키는 포인터로 타입 변환된다고 배웠다. 즉, 이 부분을 컴파일하면 다음과같은 결과를 얻는다.

    00FFFBC0

즉, 위의 문장은 컴파일러 입장에서 (00FFFBC0)++을 수행한 것이다. 당연히 오류가 뜰 것이다.
하지만 포인터의 덧셈의 경우, 자료형의 크기만큼 곱해져서 더해진다고 배웠다. 그렇기에 배열의 포인터 parr을 통해 간접적으로 arr의 덧셈을 수행하는 것이다.

여기서 생긴 궁금증. 그렇다면 arr++가 아닌, arr = arr +4를 하면 컴파일이 되지 않을까?

    while (arr < 5)
    {
        printf("%d", *arr);
        arr = arr + 4;
    }

위와같이 코드를 작성했는데, 컴파일은 불가능했다. 궁금해서 찾아보니, 그 이유는 다음과 같았다.

    배열의 주소값은 상수이다.

즉, 메모리에 저장된 배열의 주소값은 임의로 할당할 수 없는 것이었다!
이를 알고나니 이전 문서에서 주소값에 직접 00000001을 대입한 것이 생각났다. 그때도 컴파일 오류가 났었는데 메모리속 주소를 직접 변경하는것은 불가능한 것 같다.

## 포인터의 포인터

    int main()
    {
        int a;
        int* pa;
        int** ppa;
        a = 2;

        pa = &a;
        ppa = &pa;

        printf("%d, %d, %d\n", a, *pa, **ppa);
        printf("%p, %p, %p\n", &a, pa, *ppa);
        printf("%p, %p\n", &pa, ppa);

        return 0;
    }

![9](/img/pointer_9.PNG)

위 코드를 살펴보자. printf문에서 같은 행에 있는 모든 변수는 같은 값을 가진다.
a의 주소값을 가르키는 포인터 pa. 이는 &a와 같으며, pa의 주소값을 저장한 ppa가 가르키는 데이터 \*ppa와 같다.

즉, &a = pa = \*ppa이다.

마지막줄도 이와 같이 해석할 수 있다.
pa의 주소값 &pa와, 이를 저장하고있는 ppa는 같은 값이다.

## 배열 이름의 주소값

# 2 차원 배열을 가르키는 포인터 (배열 포인터)

# 포인터 배열

# 더블 포인터 (\*\*)
