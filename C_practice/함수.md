다음에 대해 꼭 이해하자.

- 함수의 필요성
- 함수의 의미, 함수의 인자, 함수의 리턴값, 함수 내부에서 선언된 변수
- main 함수

# 아주 기초적인 함수

    #include <stdio.h>

    int print_basic()
    {
        printf("아주 기초적인 함수");
        return 0;
    }

    int main()
    {
        print_basic();
        return 0;
    }

우선, 함수의 정의부분을 보자.

    int print_basic()

익숙한 단어 int가 보인다. 변수나 배열을 정의할때 뿐만 아니라, 함수를 정의할 때도 자료형이 존재한다. 위의 함수는 int형을 반환한다는 사실을 알 수 있다.

다음으로 주목할 부분은 함수의 이름. 함수의 이름은 최대한 알기 쉽게 지어야한다.

마지막부분은 괄호 ()이다. 안에 아무것도 없으니 인자가 없다는 사실을 알 수 있다.

함수의 몸체를 보자.

    {
        printf("아주 기초적인 함수");
        return 0;
    }

아주 단순하다. "아주 기초적인 함수"를 출력한 뒤, 0을 반환한다는 사실을 알 수 있다.

이제 이 함수를 직접 main함수에서 호출해보자.

    int main()
    {
        print_basic();
        return 0;
    }

main함수에서 함수를 호출하면 함수가 실행된 뒤, 원래 있던 곳으로 다시 돌아와 시작된다. 함수가 끝나는 지점은 **return**을 만나는 지점이다.
즉, return 아래 어떠한 코드가 있던 실행되지 않는다.

컴파일 결과.

![](/img/function_0.PNG)

## main 함수

    int main ()
    {
        return 0;
    }

지금까지 C언어를 배우며 항상 써왔던 main함수이다. main함수는 프로그램 맨 처음에 시작되는 함수이자, 마지막으로 종료되는 함수이다. 그런데 코드를 보면 0을 반환한다는 사실을 알 수 있다. 이 0은 어디로 가는 것일까?

**main 함수의 반환값은 운영체제에서 받아들인다.**

# 함수의 인자

    #include <stdio.h>

    int attack_buff(int damage)
    {
            damage = damage + 500;
            return damage;
    }

    int main ()
    {
            int damage = 1000;
            printf("당신의 데미지: %d\n", attack_buff(damage));

            return 0;
    }

![](/img/function_1.PNG)

함수의 정의를 보자.

    int attack_buff(int damage)

이전과 달리, 괄호 ()안에 int damage가 있는것을 알 수 있다.
위 함수는 다음과 같이 해석된다.

**나를 호출하는 코드로부터 어떤 값을 int형 damage변수에 인자로 전달하겠다.**

여기서 **인자**란 무엇일까?

인자를 이해하기 위해선 함수의 특성에 대한 이해가 선행되어야 한다.

컴퓨터는 각각의 함수에 있는 변수에 대해 전혀 모른다. 그렇기에 main함수에서 사용된 변수는 attack_buff함수에서 사용할 수 없다.
하지만, 인자는 이를 가능하게한다.

    int damage = 1000;
    printf("당신의 데미지: %d\n", attack_buff(damage));

이 코드가 호출한 attack_buff(damage)는, attack_buff(1000)과 같다. 호출된 attack_buff(damage)의 damage는

    int attack_buff(int damage)
    {
            damage = damage + 500;
            return damage;
    }

(int damage) 에 전해진다.
즉, main함수와(다른 함수도 상관없다), main함수에서 호출한 attack_buff()함수를 서로 이어주는 ()안의 값을 인자라 한다.

여기서 중요한 점. 호출된 함수에서 어떤 짓을 하던, main함수에 있는 변수엔 아무런 영향을 주지 못한다.

    int a = b;
    b ++;

위 코드에서 a는 아무런 변화가 없는 것처럼 말이다.
그렇다면 모든 함수는 항상 독립적으로 존재할까?

답은 아니다. **포인터**를 사용하면 다른 함수에서 정의된 변수를 수정할 수 있다.
