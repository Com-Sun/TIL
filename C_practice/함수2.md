# 더블 포인터 인자

함수를 통해 특정한 값을 바꾸고싶다면, **그 값을 가리키는 포인터를 인자**로 가져야한다. 더블 포인터를 인자로 가진다면 그 함수는 포인터를 바꾸는 함수일 것이다. 다음의 코드를 보면서 연습해보자.

    int pswap(int** ppa, int** ppb);

    int main() {

        int a = 1;
        int* pa;
        pa = &a;
        int b = 2;
        int* pb;
        pb = &b;

        printf("pa가 가리키는 변수의 주소값 %p, pa의 주소값 %p \n", pa, &pa);
        printf("pb가 가리키는 변수의 주소값 %p, pb의 주소값 %p \n", pb, &pb);
        printf("그냥 a, b의 주소값 %p, %p\n", &a, &b);
        printf("pa, pb가 가리키는 값 %d, %d\n\n", *pa, *pb);

        printf("스왑!! \n\n");
        pswap(&pa, &pb);

        printf("pa가 가리키는 변수의 주소값 %p, pa의 주소값 %p \n", pa, &pa);
        printf("pb가 가리키는 변수의 주소값 %p, pb의 주소값 %p \n", pb, &pb);
        printf("그냥 a, b의 주소값 %p, %p\n", &a, &b);
        return 0;
    }

    int pswap(int** ppa, int** ppb) {

        int* temp = *ppa;
        *ppa = *ppb;
        *ppb = &temp;

        return 0;
    }

![](/img/function_10.PNG)

헷갈렸던 부분 : 더블 포인터를 인자로 받으면 pa의 주소값이 바뀌어야한다고 생각했다.

깨달은 부분 : 그냥 변수를 swap하는 함수를 생각해보자. 그 함수는 가리키는 변수 자체를 바꿨다. 이번엔 그 변수의 주소값이 바뀌었다. 즉, 애초에 기획했던 포인터를 바꾸는 함수는 제대로 작동한 것이다.

내가 생각했던 pa의 주소값이 바뀌는 함수는, ppa가 바뀌는 함수이다.

# 이차원 배열 인자

이번엔 이차원 배열을 인자로 받는 함수이다.
자, 먼저 이것이 무엇을 의미하는지 알기 위해 간단한 2차원 배열을 만들어보자.

    int main() {

        int arr[2][3] = { {1,2,3}, {4,5,6} };

        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 3 ; j++) {
                printf("%d ", *arr[j]);
            }
        }

        return 0;
    }

![](/img/function_11.PNG)

엉망진창인 코드지만, 오답노트를 위해 적었다. 자꾸 컴파일 결과가 이상하게 나와서 무엇이 문제일까 고민하는 와중에 깨달았다. 배열을 출력하려면 포인터를 통해 간접적으로 i,j를 증가시켜야한다. arr++는 아예 말이 안 되는 코드이기 때문이다. (배열은 상수)

포인터를 이용하여 코드를 다시 짜 봤다. (이 과정을 통해 꾸준한 복습의 중요성에 대해 다시 한 번 깨달았다.)


# 상수 인자

# 함수 포인터
