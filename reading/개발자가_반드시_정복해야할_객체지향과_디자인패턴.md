# 2. 객체지향

### 2.1 객체의 핵심은 기능을 제공하는 것.

객체의 정의는 기능에 의해 결정된다. 객체가 어떠한 속성을 갖는지, 어떻게 그 기능을 하는지는 중요하지 않다.

### 2.2 인터페이스와 클래스

오퍼레이션: 객체가 제공하는 기능을 부르는 명칭.

즉, 객체는 오퍼레이션으로 정의된다.

오퍼레이션의 사용법은 3가지로 구성된다.

- 기능 식별 이름 (메서드이름)
- 파라미터, 파라미터 타입
- 기능 실행 결과 값 (리턴값)

이 세가지를 합쳐 시그니처라 부른다.

- 인터페이스: 객체가 제공하는 모든 오퍼레이션 집합 - 기능에 대한 명세
- 타입: 서로 다른 인터페이스를 구분하는 명칭
- 클래스: 실제 객체의 구현

### 2.3 메시지

## 3. 객체의 책임과 크기

- 객체는 기능으로 정의된다.
- 즉, 객체마다 자신의 책임이 존재한다.

타입/인터페이스: 한 객체가 갖는 책임을 정의한 것

## 4. 의존

- 의존: 한 객체가 다른 객체를 생성/호출하는 것
- 내가 변경되면 나에게 의존하는 코드에 영향을 준다.
- 나의 요구가 변경되면 내가 의존하고있는 타입에 영향을 준다.

## 5. 캡술화

- 기능 구현을 캡슐화하면 내부 구현이 변경되더라도 기능을 사용하는 곳의 영향을 최소화 한다.

### 5.4 캡슐화를 위한 두 개의 규칙

이것을 꼭 기억하자.

- Tell, Don't ask
- 데미테르의 법칙
  - 메서드에서 생성한 객체의 메서드만 호출
  - 파라미터로 받은 객체의 메서드만 호출
  - 필드로 참조하는 객체의 메서드만 호출
  
- 데미테리의 법칙을 지키지 않는 전형적인 증상 두 가지
  - 연속된 get 메서드 호출
  - 임시 변수의 get호출이 많음


## 6. 객체 지향 설계 과정

# 3. 다형성과 추상 타입

## 추상 타입과 유연함

- 추상화(abstraction): 데이터나 프로세스 등을 의미가 비슷한 개념이나 표현으로 정의하는 과정
- concrete  class: 하위클래스. 상위클래스의 실제 구현을 제공
- 변경의 유연함

### 변화되는 부분을 추상화

- 추상화가 되지 않은 코드는 `동일 구조를 갖는` if - else로 나타난다.

## TDD 와 객체지향 설계

TDD를 통해 개발을 하다보면 자연스럽게 완성하지 않은 구현으로 인해 테스트를 하기 힘든 상황이 발생한다. 이 미완성 구현을 별도의 인터페이스로 분리해보자.  구분된 인터페이스는 테스트 대상과 별도의 책임을 갖는다. 즉, `새로운 책임을 갖는 객체를 도출`하게 된다.

객체지향 설계를 유도하는 좋은 개발방법이 TDD라는 말이 괜히 나온 것이 아니다.


# 4. 재사용: 상속보단 조립

## 상속을 통한 재사용의 단점

- 상위 클래스 변경의 어려움
- 클래스의 불필요한 증가
- 상속의 오용

## 조립을 이용한 재사용

## 위임(delegation)

위임: 내가 할 일을 다른 객체에게 넘긴다.

## 상속은 언제 사용할까?

- 재사용의 관점이 아닌, 확장의 관점
- 명확한 IS - A 관계



# Part2

## 설계원칙 / DI와 서비스 로케이터

## 설계원칙: SOLID

### SRP

- SRP: 단일책임원칙
  - 책임이란 변화에 대한 것
  - 지키는 방법: 메서드를 실행하는 것이 누군인지 확인하기


### OCP

- OCP: 개방 폐쇄 원칙
  - 확장엔 열려있고, 변경엔 닫혀 있어야 한다.

개방 폐쇄원칙이 깨질 때의 주요증상

- 다운캐스팅
- 비슷한 if-else블록 존재

변화가 예쌍되는 것을 추상화해서 변경의 유연함을 얻도록 하자.

### LSP

- LSP: 리스코프 치환 원칙 (Liskov substitution principle)
  - 상위타입의 객체를 하위 타입의 객체로 치환해도 상위타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
  - 직사각형 - 정사각형
  - 개념적으로 상속관계일지라도, 구현상으로 별개의 타입으로 구현해야한다.

리스코프 치환 원칙은 기능의 명세에 대한 내용이다.

- 타입을 확인하는 기능(instanceOf) : 전형적인 리스코프 치환 원칙 위반
  - 상위타입만을 사용해서 프로그래밍할 수 없다는 뜻
  - 하위타입이 상위타입을 대체할 수 없다.
- 변화되는 부분을 상위타입에 추가한다.

### ISP

- ISP: 인터페이스 분리 원칙 (Interface segregation principle)
  - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
  - 즉, 자신이 사용하는 메서드에만 의존해야 한다.


### DIP

- DIP:의존 역전 원칙 (Dependency inversion principle)
  - 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.

# DI와 서비스 로케이터

## DI를 이용한 의존객체 사용
