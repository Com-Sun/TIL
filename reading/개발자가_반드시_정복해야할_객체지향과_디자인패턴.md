# 2. 객체지향

### 2.1 객체의 핵심은 기능을 제공하는 것.

객체의 정의는 기능에 의해 결정된다. 객체가 어떠한 속성을 갖는지, 어떻게 그 기능을 하는지는 중요하지 않다.

### 2.2 인터페이스와 클래스

오퍼레이션: 객체가 제공하는 기능을 부르는 명칭.

즉, 객체는 오퍼레이션으로 정의된다.

오퍼레이션의 사용법은 3가지로 구성된다.

- 기능 식별 이름 (메서드이름)
- 파라미터, 파라미터 타입
- 기능 실행 결과 값 (리턴값)

이 세가지를 합쳐 시그니처라 부른다.

- 인터페이스: 객체가 제공하는 모든 오퍼레이션 집합 - 기능에 대한 명세
- 타입: 서로 다른 인터페이스를 구분하는 명칭
- 클래스: 실제 객체의 구현

### 2.3 메시지

## 3. 객체의 책임과 크기

- 객체는 기능으로 정의된다.
- 즉, 객체마다 자신의 책임이 존재한다.

타입/인터페이스: 한 객체가 갖는 책임을 정의한 것

## 4. 의존

- 의존: 한 객체가 다른 객체를 생성/호출하는 것
- 내가 변경되면 나에게 의존하는 코드에 영향을 준다.
- 나의 요구가 변경되면 내가 의존하고있는 타입에 영향을 준다.

## 5. 캡술화

- 기능 구현을 캡슐화하면 내부 구현이 변경되더라도 기능을 사용하는 곳의 영향을 최소화 한다.

### 5.4 캡슐화를 위한 두 개의 규칙

이것을 꼭 기억하자.

- Tell, Don't ask
- 데미테르의 법칙
  - 메서드에서 생성한 객체의 메서드만 호출
  - 파라미터로 받은 객체의 메서드만 호출
  - 필드로 참조하는 객체의 메서드만 호출
  
- 데미테리의 법칙을 지키지 않는 전형적인 증상 두 가지
  - 연속된 get 메서드 호출
  - 임시 변수의 get호출이 많음


## 6. 객체 지향 설계 과정

# 3. 다형성과 추상 타입

## 추상 타입과 유연함

- 추상화(abstraction): 데이터나 프로세스 등을 의미가 비슷한 개념이나 표현으로 정의하는 과정
- concrete  class: 하위클래스. 상위클래스의 실제 구현을 제공
- 변경의 유연함

### 변화되는 부분을 추상화

- 추상화가 되지 않은 코드는 `동일 구조를 갖는` if - else로 나타난다.

## TDD 와 객체지향 설계

TDD를 통해 개발을 하다보면 자연스럽게 완성하지 않은 구현으로 인해 테스트를 하기 힘든 상황이 발생한다. 이 미완성 구현을 별도의 인터페이스로 분리해보자.  구분된 인터페이스는 테스트 대상과 별도의 책임을 갖는다. 즉, `새로운 책임을 갖는 객체를 도출`하게 된다.

객체지향 설계를 유도하는 좋은 개발방법이 TDD라는 말이 괜히 나온 것이 아니다.