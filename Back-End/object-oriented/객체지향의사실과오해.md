객체의 상태 : 단순한 값 + 객체의 조합. 이때 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티라고 한다.

프로퍼티는 고정된 값. 정적. 프로퍼티 값은 동적.

링크: 객체와 객체 사이의 의미있는 연결.

속성: 링크와 달리 객체를 구성하는 단순한 값

여기서 다시.

프로퍼티: 단순한 값인 속성 + 링크

**객체의 상태** 

    상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를참조하는 링크로 구분할 수 있다.

**객체의 행동**

* 객체의 행동은 상태에 영향을 받는다
* 객체의 행동은 상태를 변경시킨다.

상태라는 개념을 이용해 행동을 다음의 관점으로 서술할 수 있다.

* 상호작용이 현재의 상태에 어떤 방식으로 의존하는가
* 상호작용이 어떻게 현재의 상태를 변경시키는가

![](/img/행동.PNG)

식별자

* 동등성: 상태를 이용해 두 값이 같은지 판단할 수 있는 성질 (값)
* 동일성: 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질 (객체)

![](/img/식별자.PNG)

요약

![](/img/요약1.PNG)

**행동이 상태를 결정한다**

## 은유와 객체

의인화

은유

# 03 타입과 추상화

## 추상화를 통한 복잡성 극복

![](/img/추상화.PNG)

## 객체지향과 추상화

모두 트럼프일뿐

그룹으로 나누어 단순화하기

개념 : 공통점을 기반으로 객체들을 묶기 위한 그릇

    객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 대 객체를 개념의 인스턴스라고 한다.

## 개념의 세 가지 관점

* 심볼(symbol): 개념을 가리키는 간략한 이름이나 명칭
* 내연(intension): 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.
* 외연(extension): 개념에 속하는 모든 객체의 집합(set)

![](/img/개념2.PNG)

**개념을 이용해 객체를 분류할 수 있다**

객체를 분류하기 위한 틀

    분류란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.

분류는 추상화를 위한 도구다

## 타입

타입은 개념이다

**타입의 정의는 개념의 정의와 완전히 동일하다.(조금다를지도..?)**

    타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의마한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.


데이터 타입

    데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

객체와 타입

행동이 우선이다

## 타입의 계층

트럼프 계층

![](/img/트럼프인간.PNG)

#### 일반화/특수화 관계

일반타입 : 특수한 타입에 비해 더 적은 행동

특수타입 : 일반 타입이 가진 모든 행동 + 추가적인 행동

위의 두 가지는 동시에 일어난다. 이 때 내연과 외연의 집합 크기는 서로 반대이다. 일반이 더 많음, 행동 적음. 특수가 더 적음, 행동 많음.

#### 슈퍼타입과 서브타입

#### 일반화는 추상화를 위한 도구다

## 정적 모델

#### 타입의 목적

#### 그래서 결국 타입은 추상화다

#### 동적 모델과 정적 모델
객체를 생각할 때 두 가지 모델을 동시에 고려

스냅샷: 객체가 특정시점에 구체적으로 어떤 상태를 갖는지

객체 다이어그램: = 스냅샷

동적모델: 스냅샷처럼 실제로 객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착

타입모델: 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현

정적모델: = 타입모델

#### 클래스

정적인 모델은 클래스를 이용해 구현된다. BUT 타입 != 클래스. 클래스는 단지 타입을 구현할 수 있는 여러 구현 매커니즘 중 하나.

이것만 기억하자.

    객체를 분류하는 기준은 타입이다. 타입을 나누는 기준은 객체가 수행하는 행동이다.

# 04 역할, 책임, 협력

## 협력

#### 요청하고 응답하며 협력하는 사람들

#### 누가 파이를 훔쳤지?

#### 재판 속의 협력

## 책임

#### 책임의 분류

객체의 책임: "객체가 무엇을 알고 있는가" + "무엇을 할 수 있는가"

![](/img/아는것.PNG)

#### 책임과 메시지

## 역할

#### 책임의 집합이 의미하는 것

#### 역할이 답이다

* 단순성
* 유연성
* 재사용성

#### 협력의 추상화

#### 대체 가능성

## 객체의 모양을 결정하는 협력

#### 흔한 오류

#### 협력을 따라 흐르는 객체의 책임

## 객체지향 설계 기법

* 책임 -주도 설계 (RDD)

![](/img/1.PNG)
* 디자인 패턴 : RDD 의 결과물인 동시에 지름길
* 테스트 - 주도 개발(TDD): RDD의 목적지를 테스트라는 안전장치를 통해 도달할 수 있도록 하는 설계 방법. 다양한 설계 경험과 패턴에 대한 지식이 필요하다.


# 05 책임과 메시지

## 자율적인 책임

#### 설계의 품질을 좌우하는 책임

#### 너무 추상적인 책임

#### '어떻게'가 아니라 '무엇'을

## 메시지와 메서드

#### 메시지

#### 메서드 : 메시지를 처리하기 위해 내부적으로 선택하는 방법

#### 다형성: 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것.

#### 유연하고 확장가능하고 재사용성이 높은 협력의 의미

#### 송신자와 수신자를 약하게 연결하는 메시지

## 메시지를 따라라

#### 객체지향의 핵심, 메시지

#### 책임-주도 설계 다시 살펴보기

#### What/Who 사이클

객체가 어떤 메시지를 수신하고 처리할 수 있느냐가 객체의 책임을 결정한다.

#### 묻지 말고 시켜라

데메테르 법칙(묻지 말고 시켜라): 메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계방식.

#### 메시지를 믿어라

## 객체 인터페이스

#### 인터페이스

인터페이스는 3가지 특성을 갖는다. - (자동차와 운전자를 생각해보자)

* 인터페이스의 사용법을 익히면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있다.
* 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다.
* 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용 할 수 있다.

#### 메시지가 인터페이스를 결정한다

#### 공용 인터페이스

#### 책임, 메시지, 그리고 인터페이스

## 인터페이스와 구현의 분리

#### 객체 관점에서 생각하는 방법

* 좀 더 추상적인 인터페이스
* 최소 인터페이스
* 인터페이스와 구현 간에 차이가 있다는 점을 인식

#### 구현

구현(implementation): 객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어. 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것.

#### 인터페이스와 구현의 분리 원칙

객체를 두 개의 분리된 요소로 분할해 설계

#### 캡슐화

* 상태와 행위의 캡슐화
* 사적인 비밀의 캡슐화

## 책임의 자율성이 협력의 품질을 결정한다

1. 자율적인 책임은 협력을 단순하게 만든다.
2. 자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다.
3. 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다.
4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.
5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.

# 06 객체지도

지도: 자주 변경되는 기능이 아니라 안정적인 구조를 따라 역할, 책임, 협력을 구성하라.

## 기능 설계 vs 구조 설계

## 두 가지 재료: 기능과 구조

* 구조는 사용자나 이해관게자들이 도메인에 관해 생각하는 개념과 개념들 간의 관계로 표현한다.
* 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현한다.

유스케이스 모델링: 기능을 수집하고 표현하기 위한 기법

도메인 모델링: 구조를 수집하고 표현하기 위한 기법

두 가지 모델링 활동의 결과물: 유스케이스 모델, 도메인 모델

## 안정적인 재료: 구조

#### 도메인 모델

도메인: 사용자가 프로그램을 사용하는 대상 분야. ex) 무료함을 달래기 위한 게임 소프트웨어, 진료기록을 보관하기 위한 소프트웨어

모델: 대상을 단순화해서 표현한 것. 즉, 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태

도메인 모델: 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태

#### 도메인의 모습을 담을 수 있는 객체지향

연결완전성(or 표현적 차이): 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지 모두가 유사한 모습

#### 표현적 차이

표현적 차이: 소프트웨어 객체와 현실 객체 사이의 의미적 거리

#### 불안정한 기능을 담는 안정적인 도메인 모델

## 불안정한 재료:기능

#### 유스케이스

유스케이스: 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것

![](/img/usecase.PNG)

#### 유스케이스의 특성

유스케이스 인스턴스: 시나리오

#### 유스케이스는 설계 기법도, 객체지향 기법도 아니다.

## 재료 합치기: 기능과 구조의 통합

#### 도메인 모델, 유스케이스, 그리고 책임-주도 설계

#### 기능 변경을 흡수하는 안정적인 구조

도메인 모델을 구성하는 요소

![](/img/domain.PNG)

가역성(reversibility): 연결완전성의 역방향 역시 성립

# 07 함께 모으기

마틴 파울러- 객체지향 설계 안에 존재하는 세 가지 상호 연관된 관점

1. 개념 관점

2. 명세 관점

3. 구현 관점